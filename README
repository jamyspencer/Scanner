This project uses a unique implementation of the table concept. Instead of a 2 dimensional array of
ints that have a seperate driver it has to interact with. I created a 1 dimensional array of 122 ints mapped
to 9 abstract char types. This value is inputted into the current state object which is stored in a one
dimensional array of seven state objects(The NULL pointer handles the other two cases), these state objects
are essentially arrays of lamdas, so once the abstrct char representation is inputted into the objects array
of lamda drivers, the program goes directly to code that makes the correct state change. So it is essentially
a 2 dimesnional array of things with an int->int map to reduce redundant behavior.

Design thought process:
Having this much code loaded into memory and instanteously accesible probably creates a large memory use, but
fast execution. In application if this created a problem in the context of the larger project I would keep
the most common states loaded in memory and create/destroy the  less frequently used ones dynamically.
Another memory saving measure was to eleminate the EOF state by using the NULL pointer to represent it. Errors
and jogs in the algorithm (due to look-aheads) are also accomodated logically with the NULL pointer which gets
translated to whitespace where appropriate(virtually inserting whitespaces where they logically exist).

Verboseness vs Readability:
I started this project with a Protocol Oriented Programming, which is a Swift methodology. I continued with the
style even though my initial design changed dramatically. The design principle is that by inheriting common
functionality from parent objects you do gain brevity in source code, but it can be difficult to understand
the logic of the final object and the compiled code is the same length anyway. So I decided that defining every
case in every state explicitly in its state resulted in a more readable, easier to maintain code.

Polymorphism:
I had initially intended to have fully polymorphic objects using virtual functions, but the table design specs
made that awkward to implement, so I got polymorphic functionality through the use of constructors. Doing it this
way probably improves performance(eliminates the need for run-time binding) but loses the type enforcement
that makes polymorphism safer to maintain.